---
output:
  pdf_document: default
  html_document: default
  word_document: default
---
# Strategies implementing uncertainty models  {#Strategies}

This chapter considers both some of the wider issues related to modelling and the generalisability of results and more
technical material on the effect of covariates and model selection. From this chapter, the reader will have gained an
understanding of the following topics:

- Why having contrasts in the variables of interest is important in assessing the effects they have on the response
variable.
- The biases that may arise in the presence of covariates and how covariates can affect variable selection and model
choice.
- Hierarchical models and how that can be used to acknowledge dependence between observations.
- There are issues with using pâ€“values as measures of evidence against a null hypothesis. Basing scientific conclusions
on it can lead to non-reproducible results.
- The use of predictions from exposure models including acknowledging the additional uncertainty involved when
using predictions as inputs to a health model.
- Methods for performing model selection, including the pros and cons of automatic selection procedures.
- Model selection within the Bayesian setting and how the models themselves can be incorporated into the estimation
process using Bayesian Model Averaging.


## Example 7.6 Model choice in studies of air pollution and health {-}

```{r Example 7.6 load data, message = FALSE, warning=FALSE, error=FALSE}
library(dplyr)
library(geoR)
library(GGally)
library(ggmap)
library(ggplot2)
library(spdep)
library(nimble)
# Load data on benzene concentration in Montreal
ethylbenzene <- read.csv("data/montreal_ethylbenzene.csv")
# TODO: Add description of the data, this is the April campaign
```

```{r Example 7.6 map data, message = FALSE, warning=FALSE, error=FALSE}
# create a new variable in "sp" format and define coordinates
ethylbenzene_geo <- ethylbenzene
coordinates(ethylbenzene_geo) <- ~ lon + lat
proj4string(ethylbenzene_geo) <- CRS("+proj=longlat +datum=WGS84")
# specify the bounding box
latLongBox = bbox(ethylbenzene_geo)
location = c(latLongBox[1, 1] - 0.05,
             latLongBox[2, 1] - 0.05,
             latLongBox[1, 2] + 0.1,
             latLongBox[2, 2] + 0.05)
# create map with location dots marked on it in
MontrelEthylbenzeneMap <-
  get_stamenmap(bbox =  location,
                zoom = 10)
ggmap(MontrelEthylbenzeneMap) + geom_point(
  data = ethylbenzene,
  aes(x = lon,
      y = lat,
      size = log(Ethylbenzene)),
  col = "#011f4b",
  alpha = 0.45
) + theme_void()

```

```{r Ex 7.6 load covariates}

lur <- read.csv("data/VOC_predictors.csv")
colnames(lur)

lur$X <- lur$X/1000
lur$Y <- lur$Y/1000
```
```{r Ex 7.6 join covariates and data}
ggpairs(lur[,-c(1:3)], title="correlogram with ggpairs()", progress = FALSE)

```
Since Average and Total traffic are highly correlated, as well as Average and Total NOx, we will just use one of them.

```{r Ex 7.6 choose covs}
lur_ethyl <- lur |> select( ends_with("0m"), "X", "Y","Ethylbenzene")

# Fit a glm

glm(
  log(Ethylbenzene) ~ X + Y  +
    Building_100m +  Government.and.Institutional_1000m + Residential_1000m + 
    Pop_1000m + Roads_1000m, data = lur_ethyl )

```

### Nimble {-}

Lasso regression

```{r Ex 7.6 nimble lasso}

Ex7_6LassoCode <- nimbleCode({
  # Likelihood
  for (i in 1:n) {
    y[i]   ~ dnorm(mu[i], sd = sigma)
    mu[i] <- beta0 + inprod(X[i, ], beta[1:p])
  }
  
  # Prior specification
  for (j in 1:p) {
    beta[j] ~ ddexp(0, scale = taub * taue)
  }
  
  taue  ~  dgamma(0.1, 0.1)
  sigma <- 1/taue
  taub  ~  dgamma(0.1, 0.1)
  beta0  ~ dnorm(0, 0.01)

})

```




```{r Ex 7_6 nimble lasso run model, message = FALSE, cache = TRUE, results='hide'}
X <-  lur_ethyl |> dplyr::select( ends_with("0m"), "X", "Y")

constants <-
  list(n = nrow(lur_ethyl), p = ncol(X))

ex.data <-
  list(y = log(lur_ethyl$Ethylbenzene),
       X = scale(X))
params <- c( "beta0",  "beta", "taub","taue", "sigma")

inits <- list( sigma = 0.1, tau = 0.1)
# Run model in nimble
start_time <- Sys.time()

mcmc.out <- nimbleMCMC(
  code = Ex7_6LassoCode,
  constants = constants,
  data = ex.data,
  inits = inits,
  monitors = params,
  niter = 100000,
  nburnin = 50000,
  thin = 15,
  WAIC = TRUE,
  nchains = 2,
  summary = TRUE,
  samplesAsCodaMCMC = TRUE
)
end_time <- Sys.time()
run_time <- end_time - start_time
run_time
```

```{r Ex 7.6 nimble lasso traceplot }
min(coda::effectiveSize(mcmc.out$samples))
plot(mcmc.out$samples[, c("beta0")], bty = "n", main = "beta0")
plot(mcmc.out$samples[, c("beta[1]")], bty = "n", main = "beta1")
plot(mcmc.out$samples[, c("beta[2]")], bty = "n", main = "beta2")
plot(mcmc.out$samples[, c("beta[3]")], bty = "n", main = "beta3")
plot(mcmc.out$samples[, c("beta[4]")], bty = "n", main = "beta4")
plot(mcmc.out$samples[, c("beta[5]")], bty = "n", main = "beta5")
plot(mcmc.out$samples[, c("beta[6]")], bty = "n", main = "beta6")
plot(mcmc.out$samples[, c("beta[7]")], bty = "n", main = "beta7")
plot(mcmc.out$samples[, c("beta[8]")], bty = "n", main = "beta8")
plot(mcmc.out$samples[, c("sigma")], bty = "n", main = "sigma")
plot(mcmc.out$samples[, c("taue")], bty = "n", main = "taue")
plot(mcmc.out$samples[, c("taub")], bty = "n", main = "taub")

```

```{r Ex 7_6 nimble lasso posterior summary}
beta_var  <- paste0("beta[", 1:ncol(X), "]") 
post_summary <- mcmc.out$summary$all.chains |> as.data.frame() 
post_summary <- post_summary[beta_var,]

post_summary$variable <- colnames(X)

ggplot(post_summary,
       aes(x = variable)) + 
  geom_pointrange(aes(y = Mean, ymin =`95%CI_low`, ymax =`95%CI_upp`)) + 
  geom_hline(yintercept = 0) +
  theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```
```{r Ex 7_6 nimble horseshoe}

Ex7_6HorseshoeCode <- nimbleCode({

  # Likelihood
  for(i in 1:n){
    y[i]   ~ dnorm(mu[i], sd = sigma)
    mu[i] <- beta0 + inprod(X[i,], beta[1:p])
  }

  # Prior specification
  for(j in 1:p){
    beta[j] ~ dnorm(0, var = lambda)
  }
  lambda ~ T(dt(mu = 0, sigma = tau, df = 1), 0, Inf)
  tau  ~ T(dt(mu = 0, sigma = nu, df = 1), 0, Inf)
  nu <- sqrt(nu2)
  nu2 ~  dgamma(0.01, 0.01)
  sigma ~ T(dt(mu = 0, sigma = 1, df = 1), 0, Inf)
  beta0  ~ dnorm(0,0.01)

})

```

```{r Ex 7_6 nimble horseshoe run model, message = FALSE, cache = TRUE, results='hide'}
set.seed(321)

constants <-
  list(n = nrow(lur_ethyl), p = ncol(X))

ex.data <-
  list(y = log(lur_ethyl$Ethylbenzene),
       X = scale(X))
params <- c( "beta0",  "beta", "tau", "sigma", "lambda", "nu")

inits <- list( sigma = 0.1, tau = 0.1)
# Run model in nimble
start_time <- Sys.time()

mcmc.out <- nimbleMCMC(
  code = Ex7_6HorseshoeCode,
  constants = constants,
  data = ex.data,
  inits = inits,
  monitors = params,
  niter = 100000,
  nburnin = 50000,
  thin = 15,
  WAIC = TRUE,
  nchains = 2,
  summary = TRUE,
  samplesAsCodaMCMC = TRUE
)
end_time <- Sys.time()
run_time <- end_time - start_time
run_time
```




```{r Ex 7.6 nimble horseshoe traceplot }
min(coda::effectiveSize(mcmc.out$samples))
plot(mcmc.out$samples[, c("beta0")], bty = "n", main = "beta0")
plot(mcmc.out$samples[, c("beta[1]")], bty = "n", main = "beta1")
plot(mcmc.out$samples[, c("beta[2]")], bty = "n", main = "beta2")
plot(mcmc.out$samples[, c("beta[3]")], bty = "n", main = "beta3")
plot(mcmc.out$samples[, c("beta[4]")], bty = "n", main = "beta4")
plot(mcmc.out$samples[, c("beta[5]")], bty = "n", main = "beta5")
plot(mcmc.out$samples[, c("beta[6]")], bty = "n", main = "beta6")
plot(mcmc.out$samples[, c("beta[7]")], bty = "n", main = "beta7")
plot(mcmc.out$samples[, c("beta[8]")], bty = "n", main = "beta8")
plot(mcmc.out$samples[, c("sigma")], bty = "n", main = "sigma")
plot(mcmc.out$samples[, c("tau")], bty = "n", main = "tau")
plot(mcmc.out$samples[, c("lambda")], bty = "n", main = "lambda")
plot(mcmc.out$samples[, c("nu")], bty = "n", main = "nu")

```

 
```{r Ex 7_6 nimble horseshoe posterior summary}
beta_var  <- paste0("beta[", 1:ncol(X), "]") 
post_summary <- mcmc.out$summary$all.chains |> as.data.frame() 
post_summary <- post_summary[beta_var,]

post_summary$variable <- colnames(X)

ggplot(post_summary,
       aes(x = variable)) + 
  geom_pointrange(aes(y = Mean, ymin =`95%CI_low`, ymax =`95%CI_upp`)) + 
  geom_hline(yintercept = 0) +
  theme_classic() + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

```